[
  {
    "id": "CQ_G_1_ALL_Hierarchy_Completeness",
    "question": "Which rule classes are not properly subclasses of their implied parent? (Handles both R-code branches and Default/Mitigated leaves).",
    "sparql": "SELECT DISTINCT ?CandidateClass ?ImpliedParent WHERE { \n  ?CandidateClass a owl:Class . \n  # Match classes ending in standard suffixes \n  FILTER(REGEX(STR(?CandidateClass), '(Compliant|Violating|Default|Mitigated)$')) \n  \n  # LOGIC: If it ends in Default/Mitigated, Parent is the Compliant class. \n  # If it ends in Compliant/Violating, Parent is the Root (stripping R-code). \n  BIND( \n    IF(REGEX(STR(?CandidateClass), '(Default|Mitigated)$'), \n       IRI(REPLACE(STR(?CandidateClass), '(Default|Mitigated)$', '')), \n       IRI(REPLACE(STR(?CandidateClass), 'R[0-9]+(Compliant|Violating)$', '')) \n    ) AS ?ImpliedParent \n  ) \n  \n  # Check if the subclass relationship is missing \n  FILTER NOT EXISTS { ?CandidateClass rdfs:subClassOf ?ImpliedParent } \n  FILTER(?CandidateClass != ?ImpliedParent) \n}",
    "expected": []
  },
  {
    "id": "CQ_G_2_ALL_Violation_Disjointness",
    "question": "Which sibling outcomes are missing explicit 'disjointWith' assertions?",
    "sparql": "SELECT DISTINCT ?Parent ?ClassA ?ClassB WHERE { \n  ?ClassA rdfs:subClassOf ?Parent . \n  ?ClassB rdfs:subClassOf ?Parent . \n  FILTER(?Parent != owl:Thing) \n  FILTER(?ClassA != ?ClassB) \n  # Ensure we are looking at Rule Outcomes \n  FILTER(REGEX(STR(?ClassA), 'Compliant|Violating')) \n  FILTER(REGEX(STR(?ClassB), 'Compliant|Violating')) \n  \n  # The check: Are they disjoint? \n  FILTER NOT EXISTS { ?ClassA owl:disjointWith ?ClassB } \n  FILTER NOT EXISTS { ?ClassB owl:disjointWith ?ClassA } \n}",
    "expected": []
  },
  {
    "id": "CQ_N_G_1_Standard_Suffix_Check",
    "question": "Do all subclasses of the Root (and its children) use standard suffixes (Compliant, Violating, Default, Mitigated)?",
    "sparql": "SELECT DISTINCT ?Class WHERE { \n  # Find the Root by looking for the 'Violating' class \n  ?ViolatingClass rdfs:subClassOf ?Root . \n  FILTER(REGEX(STR(?ViolatingClass), 'R[0-9]+Violating$')) \n  \n  # Check all things under this Root \n  ?Class rdfs:subClassOf ?Root . \n  FILTER(?Class != ?Root) \n  \n  # Fail if it DOES NOT match one of the allowed suffixes \n  FILTER(!REGEX(STR(?Class), '(Compliant|Violating|Default|Mitigated)$')) \n}",
    "expected": []
  },
  {
    "id": "CQ_N_G_3_Enforce_Rule_ID_Consistency",
    "question": "Does every outcome class with a Rule ID (e.g., R171) actually belong to a Root with the correct Base Name?",
    "sparql": "SELECT DISTINCT ?Class ?ParentRoot WHERE { \n  ?Class rdfs:subClassOf ?ParentRoot . \n  FILTER(REGEX(STR(?Class), 'R[0-9]+')) \n  FILTER(?ParentRoot != owl:Thing) \n  # Ignore intermediate classes, compare to top Root \n  FILTER(!REGEX(STR(?ParentRoot), 'R[0-9]+')) \n  \n  # The string check: Does the Class name start with the Root name? \n  BIND(STRAFTER(STR(?Class), '#') AS ?ClassName) \n  BIND(STRAFTER(STR(?ParentRoot), '#') AS ?RootName) \n  FILTER(!STRSTARTS(?ClassName, ?RootName)) \n}",
    "expected": []
  }
]